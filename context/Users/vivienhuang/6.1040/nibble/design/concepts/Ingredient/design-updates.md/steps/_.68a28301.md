---
timestamp: 'Sat Oct 18 2025 21:38:42 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251018_213842.1ab4701a.md]]'
content_id: 68a283015aafbbc9b04dc48af7a6f1957bc8e13f905b416cfda55871012bdf16
---

# Implementing concepts

You're now ready to create the context that you need to implement concepts with (or without) the aid of an LLM! We've provided you with a number of documents/prompts in `design/background`, each its own self-contained bit of knowledge about concept design in general and implementing them in TypeScript.

* `design/background`: Background knowledge that you should treat as both prompts and documentation for you to read about concept design. Feel free to add any additional background documents that you think are good prompts. Also, if you think you can contribute, you may also edit any existing prompts and point them out!
* `design/brainstorm`: Plan, chat with an LLM, use as a scratch pad - create and synthesize context about your potential ideas.
* `design/concepts`: Place your actual concept spec documents here. Feel free to copy a whole document from `brainstorm` if you started there and trim down, or simply mutate in place (with `ctx prompt` or `ctx save` throughout).
* `design/learning`: When you feel like you've learned something significant, such as important decisions or caveats/challenges you encounter, record them here. **Tip:** you can always copy an entire document from another place (like `brainstorm`), add a `# summarize: extract the important lessons from everything above`, followed by a `ctx prompt`, then simply delete the original parts.

### Task:

Implement your concepts, either using LLM assistance through `ctx prompt`, or implementing by hand and documenting your progress with `ctx save`. The following tips may help:

### Sample concept: LikertSurvey

We've included a sample concept called LikertSurvey. This is a different version than shown in lecture, where the specification itself was also completely generated. You can inspect `design/concepts/LikertSurvey` to see exactly how this was done, and its history in `context`. This concept is saved, so feel free to delete the design or the source code (useful to delete at least the testing file to prevent it from running when you execute all tests).

**Generated concept:** notice that `LikertSurvey/LikertSurvey.md` is actually a link pointing to the specific **step** of that previous generation in the context! This is also an embedded link, meaning that Obsidian previews it for you automatically. You can upgrade any link to an embedded link by putting an `!` in front of it, and as long as you still have the `@` sign in the link text, Context will treat it as an include all the same.

### Implementation

Look around the background folder and see which might help you implement concepts, depending on how much of an existing design you already have. The `LikertSurvey/implementation` document gives one example of how this was done. The file that contains most of the information about the technical details of concept implementations is `implementing-concepts.md`.

### Testing

You can read about testing in `testing-concepts.md`. In general, we're using all the standard options, and for testing the current prompts use the [Deno testing framework](https://docs.deno.com/runtime/fundamentals/testing/). Tests are defined by any file with the name `filename.test.ts` in your directory. To run all tests, simply run:

```shell
deno test -A
```

where the `-A` flag means to give all permissions. Be careful with this - it's convenient, but Deno's default security model helps you find if a package you import is sneakily trying to do something your program doesn't (like load local files). There's plenty of [documentation](https://docs.deno.com/runtime/fundamentals/security/) about a more scoped approach to this.

**Confirming your setup:** run the command above to make sure that you've configured everything correctly. You should see in your MongoDB Atlas console the created collections in the test database! These are temporary and will be wiped every time you start a new test.

### Tips for including code

Since `.ts` files don't show up in Obsidian, VSCode has a similar option where you can right/ctrl click a code file, and `Copy Relative Path` to get a repo-based link to include in your context.

Context understands both the relative links generated by default when dragging files in Obsidian, as well as repo-based links. When you copy-paste these kinds of links from outside sources, you'll need to additionally prepend the link with a `/` to tell Context that it should look it up from the repo root:

```md
[@MyConceptImplementation](/src/concepts/MyConcept.ts)
```

This also turns out to be the same convention that Github uses, so you'll be able to navigate your links there too!

| Skill                         | Description (what good work looks like)                                                                                                      | Common Failures (examples of falling short)                                                                                                                                                                                                                                                                                                                                                   |
| ----------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Full implementation           | A (nearly) full set of concepts is implemented, each with a code file and a corresponding and complete specification file.                   | Several concepts are missing; implementations are missing or broken; specifications are missing or out of step with implementations; specifications are incomplete (for example, missing action definitions, or whose state is not fully declared in the standard syntax).                                                                                                                    |
| Modularity                    | Concepts are properly modular, with separation of concerns and no interdependencies.                                                         | Concepts conflate concerns by including state components and actions that belong to a different concern and could easily be separated out; concepts are dependent on one another by making calls or reading (or worse writing) each other’s state; concepts pass composite objects in actions or queries; concept code calls object methods (such as toString) on objects created externally. |
| Principle tests               | For each concept, a successful and legible test execution that corresponds to the operational principle.                                     | No test sequence is present for the operational principle; essential parts of the principle are omitted; the test sequence fails when executed; the execution is not legible because it lacks sufficient output to the console to be understandable.                                                                                                                                          |
| Variant tests                 | For each concept, 3–5 test executions that explore variants, covering all the actions and some interesting cases.                            | Insufficient number of test sequences, or tests are uninteresting; some actions have no successful test executions; executions are not legible.                                                                                                                                                                                                                                               |
| Documented design changes     | The design of the application is updated in a thoughtful and concise way.                                                                    | Design notes are unorganized, needlessly verbose, or focus only on superficial details, omitting more major issues.                                                                                                                                                                                                                                                                           |
| Recording interesting moments | Design document cites and explains 5–10 interesting moments, with a succinct but compelling explanation of each and links to relevant files. | Moments are not interesting or not explained well; links are missing, or point to mutable files that may have changed.                                                                                                                                                                                                                                                                        |
| Incremental work              | Context area has not been corrupted or modified and includes snapshots that confirm that you worked in a reflective and incremental way.     | Context has been modified or damaged; too few snapshots suggesting a lack of incremental work.                                                                                                                                                                                                                                                                                                |
