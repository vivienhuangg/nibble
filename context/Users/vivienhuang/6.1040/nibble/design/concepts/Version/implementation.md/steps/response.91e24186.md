---
timestamp: 'Sun Oct 19 2025 00:58:01 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251019_005801.b74759db.md]]'
content_id: 91e2418629ebe64eb9a27d1169d9f9cdef24ecd452c676e98bd928d43761c672
---

# response:

To implement the `Version` concept, we'll create a TypeScript class `VersionConcept` that manages `VersionDoc` documents in a MongoDB collection. This concept will also depend on `VersionDraftConcept` and `RecipeConcept` to fulfill its `draftVersionWithAI`, `approveDraft`, `rejectDraft`, and `deleteVersion` actions as described in the specification.

A mock LLM service is included to simulate AI behavior for `draftVersionWithAI`. `promptHistory` will be populated upon a draft's approval, becoming a record within the newly created `Version`.

```typescript
// file: src/Version/VersionConcept.ts
import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";
import { freshID } from "@utils/database.ts";
import VersionDraftConcept from "@concepts/VersionDraft/VersionDraftConcept.ts";
import RecipeConcept from "@concepts/Recipe/RecipeConcept.ts"; // Dependency for recipe owner checks

/**
 * concept Version [User, Recipe] (AI-Augmented)
 *
 * purpose capture concrete modifications to a recipe as immutable snapshots — with optional AI assistance that can propose draft versions from natural-language goals.
 * principle users can create versions manually or use AI to draft one (“make this vegan”, “cut sugar by half”, etc.); drafts are reviewed, edited, and either approved or rejected.
 */
// Declare collection prefix, use concept name
const PREFIX = "Version" + ".";

// Generic types of this concept
type User = ID;
type Recipe = ID;
type Version = ID; // The ID of the version document itself
type VersionDraft = ID; // The ID of a VersionDraft document

// --- Helper types for Ingredient and Step, based on Recipe concept's state ---
/**
 * represents a specific item needed for a recipe.
 */
interface Ingredient {
  name: string;
  quantity: string;
  unit?: string; // e.g., "cup", "tbsp", "g"
  notes?: string; // e.g., "freshly chopped"
}

/**
 * represents a single instruction in a recipe.
 */
interface Step {
  description: string;
  duration?: number; // in minutes
  notes?: string; // e.g., "stir until golden brown"
}

/**
 * Defines the status of an AI prompt in the history.
 */
type PromptStatus = "Approved" | "Rejected" | "Generated" | "Failed";

/**
 * An entry in the prompt history, tracking AI interactions.
 */
interface PromptHistoryEntry {
  promptText: string;
  modelName: string;
  timestamp: Date;
  draftId: VersionDraft;
  status: PromptStatus;
}
// -----------------------------------------------------------------------------

/**
 * State of the Version concept
 *
 * a set of Versions with
 *  id : UUID
 *  baseRecipe : Recipe
 *  versionNum : String
 *  author : User
 *  notes : String
 *  ingredients : List[Ingredient]
 *  steps : List[Step]
 *  created : DateTime
 *  promptHistory : List[(promptText: String, modelName: String, timestamp: DateTime, draftId: UUID, status: {Approved | Rejected | Generated | Failed})]
 */
interface VersionDoc {
  _id: ID; // Maps to concept 'id'
  baseRecipe: Recipe;
  versionNum: string;
  author: User;
  notes: string;
  ingredients: Ingredient[];
  steps: Step[];
  created: Date;
  promptHistory: PromptHistoryEntry[];
}

// Mock LLM interaction for draftVersionWithAI
// In a real scenario, this would be an API call to an actual LLM service.
async function mockLlmService(
  _recipeIngredients: Ingredient[],
  _recipeSteps: Step[],
  goal: string,
  _options: Record<string, any>,
): Promise<{ ingredients: Ingredient[]; steps: Step[]; notes: string; confidence?: number } | null> {
  // Simulate AI processing and response
  await new Promise((resolve) => setTimeout(resolve, 100)); // Simulate async work

  if (goal.includes("vegan")) {
    return {
      ingredients: [{ name: "plant-based milk", quantity: "1 cup" }],
      steps: [{ description: "Substitute plant-based milk for dairy milk." }],
      notes: "Adjusted to be vegan by replacing dairy milk.",
      confidence: 0.95,
    };
  } else if (goal.includes("cut sugar by half")) {
    return {
      ingredients: [{ name: "sugar", quantity: "0.5 cup" }], // Assuming original was 1 cup
      steps: [{ description: "Reduce sugar by 50%." }],
      notes: "Sugar content reduced by half for a less sweet taste.",
      confidence: 0.90,
    };
  } else if (goal.includes("add heat")) {
    return {
      ingredients: [{ name: "red pepper flakes", quantity: "1 tsp" }],
      steps: [{ description: "Add red pepper flakes for heat during cooking." }],
      notes: "Added red pepper flakes to introduce some spiciness.",
      confidence: 0.88,
    };
  }
  return null; // No relevant change generated by mock LLM
}

export default class VersionConcept {
  versions: Collection<VersionDoc>;
  private versionDraftConcept: VersionDraftConcept;
  private recipeConcept: RecipeConcept; // Dependency for checking recipe owner

  constructor(
    private readonly db: Db,
    versionDraftConcept: VersionDraftConcept,
    recipeConcept: RecipeConcept,
  ) {
    this.versions = this.db.collection(PREFIX + "versions");
    this.versionDraftConcept = versionDraftConcept;
    this.recipeConcept = recipeConcept;
  }

  /**
   * createVersion (author: User, recipe: Recipe, versionNum: String, notes: String, ingredients: List[Ingredient], steps: List[Step]): (version: Version) | (error: String)
   *
   * **purpose** Creates a new immutable version of a recipe manually.
   *
   * **requires** recipe exists; versionNum unique for recipe (e.g., "1.0", "1.1", "2.0"); ingredients/steps must be well-formed.
   *
   * **effects** Adds a new version linked to the base recipe, sets `created` timestamp. Returns the ID of the new version.
   */
  async createVersion(
    { author, recipe, versionNum, notes, ingredients, steps }: {
      author: User;
      recipe: Recipe;
      versionNum: string;
      notes: string;
      ingredients: Ingredient[];
      steps: Step[];
    },
  ): Promise<{ version: Version } | { error: string }> {
    if (!author || !recipe || !versionNum || !notes || !ingredients || !steps) {
      return { error: "All required fields must be provided." };
    }

    // Requires: recipe exists
    // In a strict sync model, this might be pre-verified by a sync.
    const recipeCheck = await this.recipeConcept._getRecipeById({ id: recipe });
    if ("error" in recipeCheck || recipeCheck.length === 0) {
      return { error: `Recipe with ID ${recipe} not found.` };
    }

    // Requires: versionNum unique for recipe
    const existingVersion = await this.versions.findOne({
      baseRecipe: recipe,
      versionNum: versionNum,
    });
    if (existingVersion) {
      return {
        error:
          `Version number '${versionNum}' already exists for recipe '${recipe}'.`,
      };
    }

    // Requires: ingredients and steps well-formed (basic check)
    if (!Array.isArray(ingredients) || !Array.isArray(steps)) {
      return { error: "Ingredients and steps must be arrays." };
    }

    const newId = freshID();
    const now = new Date();

    const newVersion: VersionDoc = {
      _id: newId,
      baseRecipe: recipe,
      versionNum,
      author,
      notes,
      ingredients,
      steps,
      created: now,
      promptHistory: [], // Manual versions start with empty prompt history
    };

    try {
      await this.versions.insertOne(newVersion);
      return { version: newId };
    } catch (e) {
      console.error("Error creating version:", e);
      return { error: `Failed to create version: ${e.message}` };
    }
  }

  /**
   * deleteVersion (requester: User, version: Version): Empty | (error: String)
   *
   * **purpose** Deletes a specific version of a recipe.
   *
   * **requires** requester = version.author OR requester = recipe.owner.
   *
   * **effects** Removes the specified version.
   */
  async deleteVersion(
    { requester, version: versionId }: { requester: User; version: Version },
  ): Promise<Empty | { error: string }> {
    if (!requester || !versionId) {
      return { error: "Requester and version ID must be provided." };
    }

    const targetVersion = await this.versions.findOne({ _id: versionId });
    if (!targetVersion) {
      return { error: `Version with ID ${versionId} not found.` };
    }

    // Check authorization: requester is author OR requester is recipe owner
    let isAuthorized = targetVersion.author === requester;
    if (!isAuthorized) {
      const baseRecipeResult = await this.recipeConcept._getRecipeById({
        id: targetVersion.baseRecipe,
      });
      if ("error" in baseRecipeResult || baseRecipeResult.length === 0) {
        // If the base recipe is missing, we cannot verify ownership.
        // This is an integrity issue, but we block deletion via owner if recipe is gone.
        return {
          error:
            `Cannot verify recipe owner for version ${versionId}: base recipe not found or inaccessible.`,
        };
      }
      isAuthorized = baseRecipeResult[0].owner === requester;
    }

    if (!isAuthorized) {
      return {
        error:
          `Unauthorized: Requester is neither the version author nor the recipe owner.`,
      };
    }

    try {
      const result = await this.versions.deleteOne({ _id: versionId });
      if (result.deletedCount === 0) {
        return {
          error: `Version with ID ${versionId} not found (after authorization).`,
        };
      }
      return {};
    } catch (e) {
      console.error("Error deleting version:", e);
      return { error: `Failed to delete version: ${e.message}` };
    }
  }

  /**
   * draftVersionWithAI (author: User, recipe: Recipe, goal: String, options: Record<string, any>): (id: VersionDraft) | (error: String)
   *
   * **purpose** Requests the AI to generate a provisional draft for a recipe version.
   *
   * **requires** recipe exists; goal ≠ "".
   *
   * **effects** Calls LLM with recipe content and goal, creates a VersionDraft document,
   *            and logs the interaction. Returns the ID of the new VersionDraft.
   */
  async draftVersionWithAI(
    { author, recipe, goal, options = {} }: {
      author: User;
      recipe: Recipe;
      goal: string;
      options?: Record<string, any>;
    },
  ): Promise<{ id: VersionDraft } | { error: string }> {
    if (!author || !recipe) {
      return { error: "Author and recipe ID must be provided." };
    }
    if (!goal || goal.trim() === "") {
      return { error: "Goal cannot be empty." };
    }

    // Requires: recipe exists
    const recipeResult = await this.recipeConcept._getRecipeById({ id: recipe });
    if ("error" in recipeResult || recipeResult.length === 0) {
      return { error: `Recipe with ID ${recipe} not found.` };
    }
    const baseRecipeDoc = recipeResult[0];

    // Simulate LLM call to generate draft content
    const llmResponse = await mockLlmService(
      baseRecipeDoc.ingredients,
      baseRecipeDoc.steps,
      goal,
      options,
    );

    if (!llmResponse) {
      return { error: "AI could not generate a suitable draft." };
    }

    // Create the VersionDraft using the VersionDraftConcept
    const draftCreationResult = await this.versionDraftConcept.createDraft({
      requester: author,
      baseRecipe: recipe,
      goal,
      ingredients: llmResponse.ingredients,
      steps: llmResponse.steps,
      notes: llmResponse.notes,
      confidence: llmResponse.confidence,
    });

    if ("error" in draftCreationResult) {
      return { error: `Failed to store AI draft: ${draftCreationResult.error}` };
    }

    // At this stage, a draft is 'Generated'. The promptHistory on a `Version`
    // is only updated when a draft is `Approved` into a final `Version` document.
    return { id: draftCreationResult.id };
  }

  /**
   * approveDraft (author: User, draft: VersionDraft, newVersionNum: String): (version: Version) | (error: String)
   *
   * **purpose** Promotes an AI-generated draft to an official, immutable recipe version.
   *
   * **requires** draft exists ∧ author = draft.requester ∧ newVersionNum unique for recipe.
   *
   * **effects** Creates a new Version from the draft's content, removes the draft,
   *            and logs the AI interaction status as "Approved" in the new Version's `promptHistory`.
   */
  async approveDraft(
    { author, draft: draftId, newVersionNum }: {
      author: User;
      draft: VersionDraft;
      newVersionNum: string;
    },
  ): Promise<{ version: Version } | { error: string }> {
    if (!author || !draftId || !newVersionNum) {
      return {
        error: "Author, draft ID, and new version number must be provided.",
      };
    }

    // Requires: draft exists
    const draftResult = await this.versionDraftConcept._getDraftById({
      id: draftId,
    });
    if ("error" in draftResult) {
      return { error: `Failed to retrieve draft: ${draftResult.error}` };
    }
    if (draftResult.length === 0) {
      return { error: `Version draft with ID ${draftId} not found.` };
    }
    const draftDoc = draftResult[0];

    // Requires: author = draft.requester
    if (draftDoc.requester !== author) {
      return {
        error: `Unauthorized: Only the requester '${draftDoc.requester}' can approve this draft.`,
      };
    }

    // Requires: newVersionNum unique for recipe
    const existingVersion = await this.versions.findOne({
      baseRecipe: draftDoc.baseRecipe,
      versionNum: newVersionNum,
    });
    if (existingVersion) {
      return {
        error:
          `Version number '${newVersionNum}' already exists for recipe '${draftDoc.baseRecipe}'.`,
      };
    }

    const newVersionId = freshID();
    const now = new Date();

    const newVersion: VersionDoc = {
      _id: newVersionId,
      baseRecipe: draftDoc.baseRecipe,
      versionNum: newVersionNum,
      author: author,
      notes: draftDoc.notes, // Use AI-generated notes as version notes
      ingredients: draftDoc.ingredients,
      steps: draftDoc.steps,
      created: now,
      promptHistory: [
        {
          promptText: draftDoc.goal,
          modelName: "mock-llm-v1", // Placeholder for actual LLM used
          timestamp: draftDoc.created,
          draftId: draftDoc._id,
          status: "Approved",
        },
      ],
    };

    try {
      // 1. Create the new Version
      await this.versions.insertOne(newVersion);

      // 2. Remove the draft
      const deleteDraftResult = await this.versionDraftConcept.deleteDraft({
        id: draftId,
      });
      if ("error" in deleteDraftResult) {
        // Critical: Version created but draft not deleted. Transaction management is key here.
        console.error(
          `CRITICAL: Version ${newVersionId} created but failed to delete draft ${draftId}: ${deleteDraftResult.error}`,
        );
        // Depending on requirements, could attempt to delete the new version or mark draft for manual cleanup.
        // For now, we'll return an error indicating the partial failure.
        return {
          error:
            `Version created, but failed to remove draft: ${deleteDraftResult.error}`,
        };
      }

      return { version: newVersionId };
    } catch (e) {
      console.error("Error approving draft and creating version:", e);
      // Attempt to clean up the newly created version if any subsequent operation fails
      await this.versions.deleteOne({ _id: newVersionId }); // Rollback
      return { error: `Failed to approve draft: ${e.message}` };
    }
  }

  /**
   * rejectDraft (author: User, draft: VersionDraft): Empty | (error: String)
   *
   * **purpose** Rejects an AI-generated draft, removing it from pending review.
   *
   * **requires** draft exists ∧ author = draft.requester.
   *
   * **effects** Removes the draft from transient drafts.
   */
  async rejectDraft(
    { author, draft: draftId }: { author: User; draft: VersionDraft },
  ): Promise<Empty | { error: string }> {
    if (!author || !draftId) {
      return { error: "Author and draft ID must be provided." };
    }

    // Requires: draft exists
    const draftResult = await this.versionDraftConcept._getDraftById({
      id: draftId,
    });
    if ("error" in draftResult) {
      return { error: `Failed to retrieve draft: ${draftResult.error}` };
    }
    if (draftResult.length === 0) {
      return { error: `Version draft with ID ${draftId} not found.` };
    }
    const draftDoc = draftResult[0];

    // Requires: author = draft.requester
    if (draftDoc.requester !== author) {
      return {
        error: `Unauthorized: Only the requester '${draftDoc.requester}' can reject this draft.`,
      };
    }

    try {
      // 1. Remove the draft
      const deleteDraftResult = await this.versionDraftConcept.deleteDraft({
        id: draftId,
      });
      if ("error" in deleteDraftResult) {
        return { error: `Failed to remove draft: ${deleteDraftResult.error}` };
      }

      // No `promptHistory` update on `Version` documents directly, as rejected drafts do not
      // result in a new `Version` and the `promptHistory` is part of the `Version` state.
      return {};
    } catch (e) {
      console.error("Error rejecting draft:", e);
      return { error: `Failed to reject draft: ${e.message}` };
    }
  }

  /**
   * _getVersionsByRecipe (recipe: Recipe): VersionDoc[] | (error: String)
   *
   * **purpose** Retrieves all versions associated with a given base recipe.
   *
   * **requires** The recipe ID is valid.
   *
   * **effects** Returns an array of Version documents for the specified recipe, ordered by creation date.
   */
  async _getVersionsByRecipe(
    { recipe }: { recipe: Recipe },
  ): Promise<VersionDoc[] | { error: string }> {
    if (!recipe) {
      return { error: "Recipe ID must be provided." };
    }

    try {
      const versions = await this.versions.find({ baseRecipe: recipe }).sort({
        created: 1,
      }).toArray();
      return versions;
    } catch (e) {
      console.error("Error listing versions by recipe:", e);
      return { error: `Failed to list versions: ${e.message}` };
    }
  }

  /**
   * _getVersionById (id: Version): VersionDoc[] | (error: String)
   *
   * **purpose** Retrieves a specific version by its ID.
   *
   * **requires** A Version with the given `id` exists.
   *
   * **effects** Returns an array containing the Version document if found, otherwise an empty array or an error.
   */
  async _getVersionById(
    { id }: { id: Version },
  ): Promise<VersionDoc[] | { error: string }> {
    if (!id) {
      return { error: "Version ID must be provided." };
    }

    try {
      const version = await this.versions.findOne({ _id: id });
      return version ? [version] : [];
    } catch (e) {
      console.error("Error retrieving version by ID:", e);
      return { error: `Failed to retrieve version: ${e.message}` };
    }
  }
}

// Note for the environment setup:
// For the VersionConcept to compile and run, `src/Recipe/RecipeConcept.ts` must exist and export
// a `RecipeConcept` class with at least a `_getRecipeById` method matching the expected signature.
// A minimal placeholder for `RecipeConcept` might look like:
/*
// @concepts/Recipe/RecipeConcept.ts (example placeholder if not fully implemented yet)
import { Collection, Db } from "npm:mongodb";
import { ID } from "@utils/types.ts";

interface RecipeDoc {
  _id: ID;
  owner: ID; // Crucial for VersionConcept's deleteVersion auth
  ingredients: any[];
  steps: any[];
  // ... other Recipe fields
}

export default class RecipeConcept {
  recipes: Collection<RecipeDoc>;
  constructor(private readonly db: Db) {
    this.recipes = this.db.collection("Recipe.recipes");
  }
  async _getRecipeById({ id }: { id: ID }): Promise<RecipeDoc[] | { error: string }> {
    // In a real implementation, this would fetch from the database.
    // For local testing/development without a full RecipeConcept, simulate:
    if (id === "recipe:example_recipe_id" as ID) {
      return [{ _id: id, owner: "user:example_owner_id" as ID, ingredients: [], steps: [], title: "Example Recipe", created: new Date(), updated: new Date(), tags: new Set() }];
    }
    return [];
  }
}
*/
```
