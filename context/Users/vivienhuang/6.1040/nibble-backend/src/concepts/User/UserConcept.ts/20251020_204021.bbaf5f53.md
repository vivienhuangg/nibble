---
timestamp: 'Mon Oct 20 2025 20:40:21 GMT-0400 (Eastern Daylight Time)'
content_id: bbaf5f53eb2e6e71a11061de1924ee82d9e3eb1d5ffd694033591028fe71c165
---

# file: /Users/vivienhuang/6.1040/nibble-backend/src/concepts/User/UserConcept.ts

```typescript
import type { Collection, Db } from "npm:mongodb";
import { freshID } from "@utils/database.ts";
import type { Empty, ID } from "@utils/types.ts";

/**
 * @concept User
 * @purpose represent an individual user within the system, enabling personalization, ownership, and access control.
 * @principle users are the primary actors and owners of content.
 */

// Declare collection prefix, use concept name
const PREFIX = "User" + ".";

// Define the structure of a User document in MongoDB
interface UserDoc {
  _id: ID;
  name: string;
  email: string;
  // IMPORTANT: In a production environment, passwords should ALWAYS be hashed
  // (e.g., using bcrypt) and never stored in plain text.
  // For the purpose of this exercise, we store it as a string.
  passwordHash: string;
  preferences: Record<string, unknown>; // Map[String, Any]
}

export default class UserConcept {
  users: Collection<UserDoc>;

  constructor(private readonly db: Db) {
    this.users = this.db.collection(PREFIX + "users");
    // Ensure email is indexed for uniqueness and efficient lookup
    this.users.createIndex({ email: 1 }, { unique: true });
  }

  /**
   * registerUser (name: String, email: String, password: String): (user: ID)
   *
   * @requires no user with the given `email` already exists. `name` and `password` are non-empty strings.
   * @effects creates a new user, stores `name`, `email`, and `passwordHash` (plain password for this exercise);
   *          initializes `preferences` to an empty map; returns the `ID` of the newly created user.
   */
  async registerUser({
    name,
    email,
    password,
  }: {
    name: string;
    email: string;
    password: string;
  }): Promise<{ user: ID } | { error: string }> {
    if (!name || !email || !password) {
      return { error: "Name, email, and password cannot be empty." };
    }

    // Check if user with this email already exists
    const existingUser = await this.users.findOne({ email });
    if (existingUser) {
      return { error: "A user with this email already exists." };
    }

    const newUserId = freshID();
    const newUser: UserDoc = {
      _id: newUserId,
      name,
      email,
      passwordHash: password, // Storing plain password for exercise, see security note above
      preferences: {},
    };

    await this.users.insertOne(newUser);
    return { user: newUserId };
  }

  /**
   * login (email: String, password: String): (user: ID)
   *
   * @requires a user with the given `email` and `password` exists.
   * @effects returns the `ID` of the authenticated user.
   */
  async login({
    email,
    password,
  }: {
    email: string;
    password: string;
  }): Promise<{ user: ID } | { error: string }> {
    if (!email || !password) {
      return { error: "Email and password cannot be empty." };
    }

    const user = await this.users.findOne({ email });

    // In a real app, 'password' would be hashed and compared securely
    if (!user || user.passwordHash !== password) {
      return { error: "Invalid email or password." };
    }

    return { user: user._id };
  }

  /**
   * updateProfile (user: ID, newName?: String, newEmail?: String, newPreferences?: Map[String, Any]): Empty
   *
   * @requires the `user` identified by `user: ID` must exist. If `newEmail` is provided, it must be unique among other users.
   * @effects updates the `name`, `email`, and/or `preferences` for the specified user.
   *          Returns an empty object on success.
   */
  async updateProfile({
    user: userId,
    newName,
    newEmail,
    newPreferences,
  }: {
    user: ID;
    newName?: string;
    newEmail?: string;
    newPreferences?: Record<string, unknown>;
  }): Promise<Empty | { error: string }> {
    const existingUser = await this.users.findOne({ _id: userId });
    if (!existingUser) {
      return { error: "User not found." };
    }

    const updateFields: Partial<UserDoc> = {};

    if (newName !== undefined) {
      if (typeof newName !== "string" || newName.trim() === "") {
        return { error: "New name must be a non-empty string." };
      }
      updateFields.name = newName;
    }

    if (newEmail !== undefined) {
      if (typeof newEmail !== "string" || newEmail.trim() === "") {
        return { error: "New email must be a non-empty string." };
      }
      // Check if new email is already taken by another user
      const userWithNewEmail = await this.users.findOne({ email: newEmail });
      if (userWithNewEmail && userWithNewEmail._id !== userId) {
        return { error: "This email is already taken by another user." };
      }
      updateFields.email = newEmail;
    }

    if (newPreferences !== undefined) {
      if (typeof newPreferences !== "object" || newPreferences === null) {
        return { error: "New preferences must be a valid object." };
      }
      updateFields.preferences = {
        ...existingUser.preferences,
        ...newPreferences,
      };
    }

    if (Object.keys(updateFields).length > 0) {
      await this.users.updateOne({ _id: userId }, { $set: updateFields });
    }

    return {}; // Success
  }

  // --- Queries (not explicitly required by the problem statement for User, but good practice) ---
  /**
   * _getUserDetails (user: ID): (user: { name: String, email: String, preferences: Map[String, Any] })
   *
   * @requires a user with the given `user: ID` exists.
   * @effects returns the details (name, email, preferences) of the specified user.
   */
  async _getUserDetails({ user: userId }: { user: ID }): Promise<
    | Array<{
      user: {
        name: string;
        email: string;
        preferences: Record<string, unknown>;
      };
    }>
    | { error: string }
  > {
    const user = await this.users.findOne(
      { _id: userId },
      { projection: { name: 1, email: 1, preferences: 1, _id: 0 } }, // Exclude _id and password
    );

    if (!user) {
      return { error: "User not found." };
    }

    return [
      {
        user: {
          name: user.name,
          email: user.email,
          preferences: user.preferences,
        },
      },
    ];
  }

  /**
   * _getUserIDByEmail (email: String): (user: ID)
   *
   * @requires a user with the given `email` exists.
   * @effects returns the ID of the user with the specified email.
   */
  async _getUserIDByEmail({
    email,
  }: {
    email: string;
  }): Promise<Array<{ user: ID }> | { error: string }> {
    if (!email) {
      return { error: "Email cannot be empty." };
    }

    const user = await this.users.findOne(
      { email },
      { projection: { _id: 1 } },
    );
    if (!user) {
      return { error: "User not found." };
    }

    return [{ user: user._id }];
  }
}

```
